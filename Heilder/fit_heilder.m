function [fitresult, gof, param_fix, yData_fit] = fit_heilder(tx, data)
%CREATEFIT1(TX_TOTAL,DATA_TOTAL)
%  Create a fit.
%
%  Data for 'untitled fit 1' fit:
%      X Input : tx_total
%      Y Output: data_total
%  Output:
%      fitresult : a fit object representing the fit.
%      gof : structure with goodness-of fit info.
%
%  See also FIT, CFIT, SFIT.

%  Auto-generated by MATLAB on 18-Nov-2020 18:37:52


    %% Fit: 'untitled fit 1'.
    
    [xData, yData] = prepareCurveData( tx, data );
    original_xData = xData;
    start_value = yData(1);
    yData = yData - start_value;
    selected = (yData > 0);
    yData = yData(selected);
    max_value_yData = max(yData);
    yData = (yData * 10) ./ max_value_yData;
    
    

    xData = xData(selected);

    min_xData = min(xData);

    % Move to zero
    xData = (xData - min_xData);

    % Normalize and suit to 0.05 at maximum
    max_range = 5e-2;
    xData_offset = 1e-4;
    max_value_xData = max(xData);
    xData = ((xData /  max_value_xData) * max_range) + xData_offset;

time_adapt =  max_value_xData / max_range ;
    % Set up fittype and options.
    ft = fittype( 'Io*(((t/t1).^nh)/(1 + ((t/t1).^nh)))*exp(-t/t2)', 'independent', 't', 'dependent', 'y' );
    opts = fitoptions( 'Method', 'NonlinearLeastSquares' );
    opts.DiffMaxChange = 0.001;
    opts.Display = 'Off';
    opts.Lower = [0 0 0 0];
    opts.MaxFunEvals = 10000;
    opts.MaxIter = 10000;
    opts.Robust = 'LAR';
    opts.StartPoint = [0.136068558708664 0.869292207640089 0.57970458736557 0.549860201836332];

    % Fit model to data.
    [fitresult, gof] = fit( xData, yData, ft, opts );

    % Plot fit with data.
    %{
    figure( 'Name', 'untitled fit 1' );
    h = plot( fitresult, xData, yData );
    legend( h, 'data_total vs. tx_total', 'untitled fit 1', 'Location', 'NorthEast', 'Interpreter', 'none' );
    % Label axes
    xlabel( 'tx_total', 'Interpreter', 'none' );
    ylabel( 'data_total', 'Interpreter', 'none' );
    grid on
    %}
    
    x_to_fit = linspace(0, max_range, length(original_xData)) + xData_offset;
    yData_fit = fitresult(x_to_fit);
    
    yData_fit = ((yData_fit / 10 ) * max_value_yData) + start_value;
    
    param_fix.t1 = (fitresult.t1 / max_range) * max_value_xData;
    param_fix.t2 = (fitresult.t2 / max_range) * max_value_xData;
    param_fix.nh = fitresult.nh;
    param_fix.Io = (fitresult.Io / 10 ) * max_value_yData;
    
    tx_to_find = [0 : 1e-4 : 100*max_range];
    values_to_find = fitresult(tx_to_find);
    
    [max_value,max_index] = (max(values_to_find));
    rise_part_tx = tx_to_find(1:max_index);
    rise_part_values = values_to_find(1:max_index);
    
    fall_part_tx = tx_to_find(max_index:end);
    fall_part_values = values_to_find(max_index:end);
    
    
    max_position = tx_to_find(max_index);
    
    param_fix.T1 = (max_position - xData_offset) * time_adapt;
    stop = 0.1 * max(values_to_find);
    
    distant_to_limit = abs(fall_part_values - stop);
    position_final = fall_part_tx(distant_to_limit == min(distant_to_limit));
    param_fix.T2 = (position_final - max_position) * time_adapt;
    
    %%Rise Time
    
    T10_limit = 0.1 * max_value;
    T10_distant = abs(rise_part_values - T10_limit);
    [~, T10_index] = min(T10_distant);
    T10 = rise_part_tx(T10_index);
    
    T90_limit = 0.9 * max_value;
    T90_distant = abs(rise_part_values - T90_limit);
    [~, T90_index] = min(T90_distant);
    T90 = rise_part_tx(T90_index);
    
    param_fix.RiseTime = (T90 - T10 ) * time_adapt;
   %% FWHMT:
   
   T50_limit = 0.1 * max_value;
   T50_distant_left = abs(rise_part_values - T50_limit);
   T50_distant_right = abs(fall_part_values - T50_limit);
   [~, T50_index_left] = min(T50_distant_left);
   [~, T50_index_right] = min(T50_distant_right);
    T50_left = rise_part_tx(T50_index_left);
    T50_right = fall_part_tx(T50_index_right);
    param_fix.FWHMT = (T50_right - T50_left ) * time_adapt;
    
    
end